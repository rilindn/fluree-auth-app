"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var combine_errors_1 = tslib_1.__importDefault(require("combine-errors"));
var imurmurhash_1 = tslib_1.__importDefault(require("imurmurhash"));
var Model = tslib_1.__importStar(require("./model"));
exports.Model = Model;
var constants_1 = require("../constants");
var DEFAULT_ATOMIC_OPTIONS = {
    fsync: false,
};
var generateTmpFileName = (function () {
    var getTmpFilePathInvocation = 0;
    return function (file) { return file + "." + imurmurhash_1.default(__filename)
        .hash(String(process.pid))
        .hash(String(++getTmpFilePathInvocation))
        .hash(Number(new Date()))
        .result(); };
})();
function writeFileAtomic(fs, filePath /*| number*/, data, writeFileOptions, atomicOptionsInput) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var atomicOptions, file, tmpFile, renameError_1, errors, unlinkError_1;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    atomicOptions = tslib_1.__assign(tslib_1.__assign({}, DEFAULT_ATOMIC_OPTIONS), atomicOptionsInput);
                    file = filePath.toString();
                    return [4 /*yield*/, (function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var fileStats, error_1, resultFile, _a, _b, fd;
                            return tslib_1.__generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _c.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, fs.stat(file)];
                                    case 1:
                                        fileStats = _c.sent();
                                        return [3 /*break*/, 3];
                                    case 2:
                                        error_1 = _c.sent();
                                        if (error_1.code !== constants_1.FS_ERROR_CODE_ENOENT) {
                                            throw error_1;
                                        }
                                        return [3 /*break*/, 3];
                                    case 3:
                                        _a = generateTmpFileName;
                                        if (!fileStats) return [3 /*break*/, 5];
                                        return [4 /*yield*/, fs.realpath(file)];
                                    case 4:
                                        _b = _c.sent();
                                        return [3 /*break*/, 6];
                                    case 5:
                                        _b = file;
                                        _c.label = 6;
                                    case 6:
                                        resultFile = _a.apply(void 0, [_b]);
                                        return [4 /*yield*/, fs.open(resultFile, "w")];
                                    case 7:
                                        fd = _c.sent();
                                        _c.label = 8;
                                    case 8:
                                        _c.trys.push([8, , 12, 14]);
                                        return [4 /*yield*/, fs.writeFile(resultFile, data, writeFileOptions)];
                                    case 9:
                                        _c.sent();
                                        if (!atomicOptions.fsync) return [3 /*break*/, 11];
                                        return [4 /*yield*/, fs.fsync(fd)];
                                    case 10:
                                        _c.sent();
                                        _c.label = 11;
                                    case 11: return [3 /*break*/, 14];
                                    case 12: return [4 /*yield*/, fs.close(fd)];
                                    case 13:
                                        _c.sent();
                                        return [7 /*endfinally*/];
                                    case 14:
                                        if (!fileStats) return [3 /*break*/, 18];
                                        if (!!atomicOptions.disableChown) return [3 /*break*/, 16];
                                        return [4 /*yield*/, fs.chown(resultFile, fileStats.uid, fileStats.gid)];
                                    case 15:
                                        _c.sent();
                                        _c.label = 16;
                                    case 16:
                                        if (!!atomicOptions.disableChmod) return [3 /*break*/, 18];
                                        return [4 /*yield*/, fs.chmod(resultFile, fileStats.mode)];
                                    case 17:
                                        _c.sent();
                                        _c.label = 18;
                                    case 18: return [2 /*return*/, resultFile];
                                }
                            });
                        }); })()];
                case 1:
                    tmpFile = _a.sent();
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 9]);
                    return [4 /*yield*/, fs.rename(tmpFile, file)];
                case 3: return [2 /*return*/, _a.sent()];
                case 4:
                    renameError_1 = _a.sent();
                    errors = [
                        renameError_1,
                        new Error("Failed to rename \"" + tmpFile + "\" => \"" + file + "\"."),
                    ];
                    _a.label = 5;
                case 5:
                    _a.trys.push([5, 7, , 8]);
                    return [4 /*yield*/, fs.unlink(tmpFile)];
                case 6:
                    _a.sent();
                    return [3 /*break*/, 8];
                case 7:
                    unlinkError_1 = _a.sent();
                    errors.push(unlinkError_1);
                    return [3 /*break*/, 8];
                case 8: throw combine_errors_1.default(errors);
                case 9: return [2 /*return*/];
            }
        });
    });
}
exports.writeFileAtomic = writeFileAtomic;
//# sourceMappingURL=index.js.map