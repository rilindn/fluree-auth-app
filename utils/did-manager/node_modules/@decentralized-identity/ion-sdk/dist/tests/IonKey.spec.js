var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { IonKey, IonPublicKeyPurpose } from '../lib/index.js';
import ErrorCode from '../lib/ErrorCode.js';
import JasmineIonErrorValidator from './JasmineIonErrorValidator.js';
// NOTE: @noble/secp256k1 requires globalThis.crypto polyfill for node.js <=18: https://github.com/paulmillr/noble-secp256k1/blob/main/README.md#usage
// Remove when we move off of node.js v18 to v20, earliest possible time would be Oct 2023: https://github.com/nodejs/release#release-schedule
if (parseInt(process.versions.node) <= 18) {
    import('node:crypto').then(({ webcrypto }) => {
        // @ts-ignore
        if (!globalThis.crypto) {
            globalThis.crypto = webcrypto;
        }
        // Continue with your code that uses `crypto`
    });
}
describe('IonKey', () => __awaiter(void 0, void 0, void 0, function* () {
    describe('generateEs256kOperationKeyPair()', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should create a key pair successfully.', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKey, privateKey] = yield IonKey.generateEs256kOperationKeyPair();
            expect(Object.keys(publicKey).length).toEqual(4);
            expect(Object.keys(privateKey).length).toEqual(5);
            expect(publicKey.d).toBeUndefined();
            expect(privateKey.d).toBeDefined();
            expect(publicKey.crv).toEqual(privateKey.crv);
            expect(publicKey.kty).toEqual(privateKey.kty);
            expect(publicKey.x).toEqual(privateKey.x);
            expect(publicKey.y).toEqual(privateKey.y);
        }));
    }));
    describe('generateEs256kDidDocumentKeyPair()', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should create a key pair successfully.', () => __awaiter(void 0, void 0, void 0, function* () {
            const keyId = 'anyId';
            const [didDocumentPublicKey, privateKey] = yield IonKey.generateEs256kDidDocumentKeyPair({ id: keyId, purposes: [IonPublicKeyPurpose.Authentication] });
            expect(didDocumentPublicKey.id).toEqual(keyId);
            expect(didDocumentPublicKey.purposes).toEqual([IonPublicKeyPurpose.Authentication]);
            expect(didDocumentPublicKey.type).toEqual('EcdsaSecp256k1VerificationKey2019');
            expect(Object.keys(didDocumentPublicKey.publicKeyJwk).length).toEqual(4);
            expect(Object.keys(privateKey).length).toEqual(5);
            expect(privateKey.d).toBeDefined();
            const publicKey = didDocumentPublicKey.publicKeyJwk;
            expect(publicKey.d).toBeUndefined();
            expect(publicKey.crv).toEqual(privateKey.crv);
            expect(publicKey.kty).toEqual(privateKey.kty);
            expect(publicKey.x).toEqual(privateKey.x);
            expect(publicKey.y).toEqual(privateKey.y);
        }));
        it('should throw error if given DID Document key ID exceeds maximum length.', () => __awaiter(void 0, void 0, void 0, function* () {
            const id = 'superDuperLongDidDocumentKeyIdentifierThatExceedsMaximumLength'; // Overwrite with super long string.
            yield JasmineIonErrorValidator.expectIonErrorToBeThrownAsync(() => __awaiter(void 0, void 0, void 0, function* () { return IonKey.generateEs256kDidDocumentKeyPair({ id, purposes: [IonPublicKeyPurpose.Authentication] }); }), ErrorCode.IdTooLong);
        }));
        it('should throw error if given DID Document key ID is not using base64URL character set. ', () => __awaiter(void 0, void 0, void 0, function* () {
            const id = 'nonBase64urlString!';
            yield JasmineIonErrorValidator.expectIonErrorToBeThrownAsync(() => __awaiter(void 0, void 0, void 0, function* () { return IonKey.generateEs256kDidDocumentKeyPair({ id, purposes: [IonPublicKeyPurpose.Authentication] }); }), ErrorCode.IdNotUsingBase64UrlCharacterSet);
        }));
        it('should allow DID Document key to not have a purpose defined.', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKeyModel1] = yield IonKey.generateEs256kDidDocumentKeyPair({ id: 'id1', purposes: [] });
            expect(publicKeyModel1.id).toEqual('id1');
            expect(publicKeyModel1.purposes).toBeUndefined();
            const [publicKeyModel2] = yield IonKey.generateEs256kDidDocumentKeyPair({ id: 'id2' });
            expect(publicKeyModel2.id).toEqual('id2');
            expect(publicKeyModel2.purposes).toBeUndefined();
        }));
        it('should throw error if given DID Document key has duplicated purposes.', () => __awaiter(void 0, void 0, void 0, function* () {
            yield JasmineIonErrorValidator.expectIonErrorToBeThrownAsync(() => __awaiter(void 0, void 0, void 0, function* () { return IonKey.generateEs256kDidDocumentKeyPair({ id: 'anyId', purposes: [IonPublicKeyPurpose.Authentication, IonPublicKeyPurpose.Authentication] }); }), ErrorCode.PublicKeyPurposeDuplicated);
        }));
    }));
    describe('isJwkEs256k()', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should return true for a JwkEs256K key', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKey, privateKey] = yield IonKey.generateEs256kOperationKeyPair();
            expect(IonKey.isJwkEs256k(publicKey)).toBeTruthy();
            expect(IonKey.isJwkEs256k(privateKey)).toBeTruthy();
        }));
        it('should return false for a JwkEd25519 key', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKey, privateKey] = yield IonKey.generateEd25519OperationKeyPair();
            expect(IonKey.isJwkEs256k(publicKey)).toBeFalsy();
            expect(IonKey.isJwkEs256k(privateKey)).toBeFalsy();
        }));
    }));
    describe('generateEd25519OperationKeyPair()', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should create a key pair successfully.', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKey, privateKey] = yield IonKey.generateEd25519OperationKeyPair();
            expect(Object.keys(publicKey).length).toEqual(3);
            expect(Object.keys(privateKey).length).toEqual(4);
            expect(publicKey.d).toBeUndefined();
            expect(privateKey.d).toBeDefined();
            expect(publicKey.crv).toEqual(privateKey.crv);
            expect(publicKey.kty).toEqual(privateKey.kty);
            expect(publicKey.x).toEqual(privateKey.x);
        }));
    }));
    describe('generateEd25519DidDocumentKeyPair()', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should create a key pair successfully.', () => __awaiter(void 0, void 0, void 0, function* () {
            const keyId = 'anyId';
            const [didDocumentPublicKey, privateKey] = yield IonKey.generateEd25519DidDocumentKeyPair({ id: keyId, purposes: [IonPublicKeyPurpose.Authentication] });
            expect(didDocumentPublicKey.id).toEqual(keyId);
            expect(didDocumentPublicKey.purposes).toEqual([IonPublicKeyPurpose.Authentication]);
            expect(didDocumentPublicKey.type).toEqual('JsonWebKey2020');
            expect(Object.keys(didDocumentPublicKey.publicKeyJwk).length).toEqual(3);
            expect(Object.keys(privateKey).length).toEqual(4);
            expect(privateKey.d).toBeDefined();
            const publicKey = didDocumentPublicKey.publicKeyJwk;
            expect(publicKey.d).toBeUndefined();
            expect(publicKey.crv).toEqual(privateKey.crv);
            expect(publicKey.kty).toEqual(privateKey.kty);
            expect(publicKey.x).toEqual(privateKey.x);
        }));
        it('should throw error if given DID Document key ID exceeds maximum length.', () => __awaiter(void 0, void 0, void 0, function* () {
            const id = 'superDuperLongDidDocumentKeyIdentifierThatExceedsMaximumLength'; // Overwrite with super long string.
            yield JasmineIonErrorValidator.expectIonErrorToBeThrownAsync(() => __awaiter(void 0, void 0, void 0, function* () { return IonKey.generateEd25519DidDocumentKeyPair({ id, purposes: [IonPublicKeyPurpose.Authentication] }); }), ErrorCode.IdTooLong);
        }));
        it('should throw error if given DID Document key ID is not using base64URL character set. ', () => __awaiter(void 0, void 0, void 0, function* () {
            const id = 'nonBase64urlString!';
            yield JasmineIonErrorValidator.expectIonErrorToBeThrownAsync(() => __awaiter(void 0, void 0, void 0, function* () { return IonKey.generateEd25519DidDocumentKeyPair({ id, purposes: [IonPublicKeyPurpose.Authentication] }); }), ErrorCode.IdNotUsingBase64UrlCharacterSet);
        }));
        it('should allow DID Document key to not have a purpose defined.', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKeyModel1] = yield IonKey.generateEd25519DidDocumentKeyPair({ id: 'id1', purposes: [] });
            expect(publicKeyModel1.id).toEqual('id1');
            expect(publicKeyModel1.purposes).toBeUndefined();
            const [publicKeyModel2] = yield IonKey.generateEd25519DidDocumentKeyPair({ id: 'id2' });
            expect(publicKeyModel2.id).toEqual('id2');
            expect(publicKeyModel2.purposes).toBeUndefined();
        }));
        it('should throw error if given DID Document key has duplicated purposes.', () => __awaiter(void 0, void 0, void 0, function* () {
            yield JasmineIonErrorValidator.expectIonErrorToBeThrownAsync(() => __awaiter(void 0, void 0, void 0, function* () { return IonKey.generateEd25519DidDocumentKeyPair({ id: 'anyId', purposes: [IonPublicKeyPurpose.Authentication, IonPublicKeyPurpose.Authentication] }); }), ErrorCode.PublicKeyPurposeDuplicated);
        }));
    }));
    describe('isJwkEd25519()', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should return false for a JwkEs256K key', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKey, privateKey] = yield IonKey.generateEs256kOperationKeyPair();
            expect(IonKey.isJwkEd25519(publicKey)).toBeFalsy();
            expect(IonKey.isJwkEd25519(privateKey)).toBeFalsy();
        }));
        it('should return false for a JwkEd25519 key', () => __awaiter(void 0, void 0, void 0, function* () {
            const [publicKey, privateKey] = yield IonKey.generateEd25519OperationKeyPair();
            expect(IonKey.isJwkEd25519(publicKey)).toBeTruthy();
            expect(IonKey.isJwkEd25519(privateKey)).toBeTruthy();
        }));
    }));
}));
//# sourceMappingURL=IonKey.spec.js.map