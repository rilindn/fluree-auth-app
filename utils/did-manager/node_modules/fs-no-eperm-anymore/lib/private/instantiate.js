"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var os_1 = require("os");
var index_1 = require("./index");
var constants_1 = require("./constants");
var CURRENT_PLATFORM = os_1.platform();
function instantiate(options) {
    return Object.keys(constants_1.FUNCTIONS)
        .reduce(function (map, fnName) {
        var fn = constants_1.FUNCTIONS[fnName];
        map[fnName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return retryLoop(fnName, function () { return fn.apply(void 0, args); }, options || constants_1.DEFAULT_OPTIONS);
        };
        return map;
    }, {});
}
exports.instantiate = instantiate;
function retryLoop(fnName, action, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var actionExecutionAttempt, startTime, iteration;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    actionExecutionAttempt = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var error_1, attemptOptions_1, timeDiffMs;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 6]);
                                    iteration++;
                                    if (options.verbose) {
                                        // tslint:disable:no-console
                                        console.log("iteration:", JSON.stringify({ pid: process.pid, function: fnName, iteration: iteration }));
                                        // tslint:enable:no-console
                                    }
                                    return [4 /*yield*/, action()];
                                case 1: return [2 /*return*/, _a.sent()];
                                case 2:
                                    error_1 = _a.sent();
                                    if (!error_1.code) {
                                        throw error_1;
                                    }
                                    attemptOptions_1 = resolveAttemptOptions(fnName, error_1.code, options);
                                    if (!attemptOptions_1
                                        || typeof attemptOptions_1.retryIntervalMs !== "number"
                                        || typeof attemptOptions_1.retryTimeoutMs !== "number") {
                                        throw error_1;
                                    }
                                    timeDiffMs = index_1.nowMs() - startTime;
                                    if (!(timeDiffMs < attemptOptions_1.retryTimeoutMs)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, attemptOptions_1.retryIntervalMs); })];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, actionExecutionAttempt()];
                                case 4: return [2 /*return*/, _a.sent()];
                                case 5:
                                    if (options.verbose) {
                                        // tslint:disable:no-console
                                        console.log("timeout:", JSON.stringify({ pid: process.pid, function: fnName, iteration: iteration, timeDiffMs: timeDiffMs, attemptOptions: attemptOptions_1 }));
                                        // tslint:enable:no-console
                                    }
                                    throw error_1;
                                case 6: return [2 /*return*/];
                            }
                        });
                    }); };
                    startTime = index_1.nowMs();
                    iteration = 0;
                    return [4 /*yield*/, actionExecutionAttempt()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function resolveAttemptOptions(fnName, errorCode, _a) {
    var items = _a.items;
    var resolvedItems = items.reduce(function (result, _a) {
        var platforms = _a.platforms, errorCodes = _a.errorCodes, functions = _a.functions, options = _a.options;
        var weight = 0;
        if (!platforms || !platforms.length) {
            weight += 1;
        }
        else if (platforms.indexOf(CURRENT_PLATFORM) !== -1) {
            weight += 10;
        }
        else {
            return result;
        }
        if (!errorCodes || !errorCodes.length) {
            weight += 1;
        }
        else if (errorCodes.indexOf(errorCode) !== -1) {
            weight += 20;
        }
        else {
            return result;
        }
        if (!functions || !functions.length) {
            weight += 1;
        }
        else if (functions.indexOf(fnName) !== -1) {
            weight += 50;
        }
        else {
            return result;
        }
        if (weight) {
            result.push({ weight: weight, options: options });
        }
        return result;
    }, []);
    // order by "weight" desc
    resolvedItems.sort(function (a, b) { return b.weight - a.weight; });
    var resolveItem = resolvedItems.shift();
    if (resolveItem) {
        return resolveItem.options;
    }
    return;
}
exports.resolveAttemptOptions = resolveAttemptOptions;
//# sourceMappingURL=instantiate.js.map