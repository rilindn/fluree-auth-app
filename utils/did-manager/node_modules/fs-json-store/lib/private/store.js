"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var kind_of_1 = tslib_1.__importDefault(require("kind-of"));
var path_1 = tslib_1.__importDefault(require("path"));
var proper_lockfile_1 = tslib_1.__importDefault(require("proper-lockfile"));
var util_1 = require("util");
var index_1 = require("./fs-impl/fs/index");
var constants_1 = require("./constants");
var mem_fs_1 = require("./fs-impl/mem-fs");
var Store = /** @class */ (function () {
    function Store(options) {
        this.options = Object.freeze(tslib_1.__assign(tslib_1.__assign({}, options), { fs: options.fs || index_1.fs }));
        this.serialize = options.serialize || (function (data) { return Buffer.from(JSON.stringify(data)); });
        this.deserialize = options.deserialize || (function (data) { return JSON.parse(Buffer.from(data).toString()); });
    }
    Object.defineProperty(Store.prototype, "adapter", {
        get: function () {
            return this.options.adapter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "file", {
        get: function () {
            return this.options.file;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "fs", {
        get: function () {
            return this.options.fs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "optimisticLocking", {
        get: function () {
            return this.options.optimisticLocking || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Store.prototype, "validators", {
        get: function () {
            return this.options.validators;
        },
        enumerable: true,
        configurable: true
    });
    Store.prototype.clone = function (opts) {
        return new Store(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.options), opts), { 
            // enforcing options state to always have the "file" property filled
            file: path_1.default.resolve(opts && opts.file || this.file) }));
    };
    Store.prototype.readable = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var fd, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.fs.open(this.file, "r+")];
                    case 1:
                        fd = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        if (error_1.code === constants_1.FS_ERROR_CODE_ENOENT) {
                            return [2 /*return*/, false];
                        }
                        throw error_1;
                    case 3: return [4 /*yield*/, this.fs.close(fd)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, true];
                }
            });
        });
    };
    Store.prototype.readExisting = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.read(options)];
                    case 1:
                        response = _a.sent();
                        if (!response) {
                            throw new Error(this.file + " does not exist");
                        }
                        return [2 /*return*/, response];
                }
            });
        });
    };
    Store.prototype.read = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var readable, buffer, adapter, adaptedBuffer, _a, data;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.readable()];
                    case 1:
                        readable = _b.sent();
                        if (!readable) {
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, this.fs.readFile(this.file)];
                    case 2:
                        buffer = _b.sent();
                        adapter = (options && options.adapter) || this.adapter;
                        if (!adapter) return [3 /*break*/, 4];
                        return [4 /*yield*/, adapter.read(buffer)];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        _a = buffer;
                        _b.label = 5;
                    case 5:
                        adaptedBuffer = _a;
                        data = this.deserialize(adaptedBuffer);
                        return [4 /*yield*/, this.validate(data, "Reading validation: ")];
                    case 6:
                        _b.sent();
                        return [2 /*return*/, data];
                }
            });
        });
    };
    Store.prototype.write = function (data, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var dataType, dir, err_1, finalAction, nextRevision, releaseLock;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dataType = kind_of_1.default(data);
                        dir = path_1.default.dirname(this.file);
                        if (this.optimisticLocking && dataType !== "object") {
                            throw new Error([
                                "With the optimistic locking enabled stored data must be of the \"object\" type, ",
                                "while passed for writing data is of the \"" + dataType + "\" type.",
                            ].join(""));
                        }
                        return [4 /*yield*/, this.validate(data, "Writing validation: ")];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 8]);
                        return [4 /*yield*/, this.fs.stat(dir)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 4:
                        err_1 = _a.sent();
                        if (!(err_1.code === constants_1.FS_ERROR_CODE_ENOENT)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.mkdirRecursive(dir)];
                    case 5:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 6: throw err_1;
                    case 7: return [3 /*break*/, 8];
                    case 8:
                        finalAction = function (dataToSave) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var buffer, adaptedBuffer, _a;
                            return tslib_1.__generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        buffer = Buffer.from(this.serialize(dataToSave));
                                        if (!this.adapter) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.adapter.write(buffer)];
                                    case 1:
                                        _a = _b.sent();
                                        return [3 /*break*/, 3];
                                    case 2:
                                        _a = buffer;
                                        _b.label = 3;
                                    case 3:
                                        adaptedBuffer = _a;
                                        return [4 /*yield*/, this.fs.writeFileAtomic(this.file, adaptedBuffer)];
                                    case 4:
                                        _b.sent();
                                        return [2 /*return*/, this.readExisting()];
                                }
                            });
                        }); };
                        if (!this.optimisticLocking) return [3 /*break*/, 15];
                        return [4 /*yield*/, this.resolveNewRevision(data, options && options.readAdapter)];
                    case 9:
                        nextRevision = _a.sent();
                        return [4 /*yield*/, proper_lockfile_1.default.lock("" + this.file, { fs: this.callbackifiedFsImpl(), realpath: false })];
                    case 10:
                        releaseLock = _a.sent();
                        _a.label = 11;
                    case 11:
                        _a.trys.push([11, , 13, 15]);
                        return [4 /*yield*/, finalAction(Object.assign({}, data, { _rev: nextRevision }))];
                    case 12: return [2 /*return*/, _a.sent()];
                    case 13: return [4 /*yield*/, releaseLock()];
                    case 14:
                        _a.sent();
                        return [7 /*endfinally*/];
                    case 15: return [4 /*yield*/, finalAction(data)];
                    case 16: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Store.prototype.validate = function (data, messagePrefix) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _i, _a, validator, invalidMessage;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.validators || !this.validators.length) {
                            return [2 /*return*/];
                        }
                        _i = 0, _a = this.validators;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        validator = _a[_i];
                        return [4 /*yield*/, validator(data)];
                    case 2:
                        invalidMessage = _b.sent();
                        if (invalidMessage !== null) {
                            throw new Error("" + (messagePrefix || "") + invalidMessage);
                        }
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Store.prototype.remove = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fs.unlink(this.file)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Store.prototype.resolveNewRevision = function (payloadData, readAdapter) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var payloadRev, storedData, storedRev, payloadDataVersioned, storedDataVersioned;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        payloadRev = payloadData._rev;
                        return [4 /*yield*/, this.read({ adapter: readAdapter })];
                    case 1:
                        storedData = _a.sent();
                        if (!storedData) {
                            return [2 /*return*/, typeof payloadRev === "number" ? payloadRev : 0];
                        }
                        storedRev = storedData._rev;
                        payloadDataVersioned = typeof payloadRev === "number";
                        storedDataVersioned = typeof storedRev === "number";
                        if (!storedDataVersioned && payloadDataVersioned) {
                            throw new Error("Version value (" + payloadRev + ") can't be passed for updating unversioned file \"" + this.file + "\"");
                        }
                        if (!storedDataVersioned || typeof payloadRev !== "number" || storedRev !== payloadRev) {
                            throw new Error([
                                "\"" + this.file + "\" has been updated by another process. ",
                                "Revisions of the persisted (" + storedRev + ") and payload (" + payloadRev + ") data don't match",
                            ].join(""));
                        }
                        return [2 /*return*/, storedRev + 1];
                }
            });
        });
    };
    Store.prototype.mkdirRecursive = function (value) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var folderNames, pathsToCreate, i, partialPath, err_2, _i, pathsToCreate_1, pathToCreate, error_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        folderNames = value.split(path_1.default.sep);
                        pathsToCreate = [];
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < folderNames.length)) return [3 /*break*/, 7];
                        partialPath = folderNames
                            .slice(0, folderNames.length - i)
                            .join(path_1.default.sep);
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.fs.stat(partialPath)];
                    case 3:
                        if ((_a.sent()).isDirectory()) {
                            return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        err_2 = _a.sent();
                        if (err_2.code !== constants_1.FS_ERROR_CODE_ENOENT) {
                            throw err_2;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        if (partialPath) {
                            pathsToCreate.push(partialPath);
                        }
                        _a.label = 6;
                    case 6:
                        i++;
                        return [3 /*break*/, 1];
                    case 7:
                        pathsToCreate.reverse();
                        _i = 0, pathsToCreate_1 = pathsToCreate;
                        _a.label = 8;
                    case 8:
                        if (!(_i < pathsToCreate_1.length)) return [3 /*break*/, 13];
                        pathToCreate = pathsToCreate_1[_i];
                        _a.label = 9;
                    case 9:
                        _a.trys.push([9, 11, , 12]);
                        return [4 /*yield*/, this.fs.mkdir(pathToCreate, constants_1.MKDIR_MODE)];
                    case 10:
                        _a.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        error_2 = _a.sent();
                        if (error_2.code !== constants_1.FS_ERROR_CODE_EEXIST) { // directory might already be created by another/parallel process
                            throw error_2;
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        _i++;
                        return [3 /*break*/, 8];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    Store.prototype.callbackifiedFsImpl = function () {
        var _this = this;
        if (this.fs._name === mem_fs_1.NAME) {
            return this.fs._impl;
        }
        return Object
            .keys(this.fs._impl)
            .filter(function (key) {
            return !["writeFileAtomic", "impl"].includes(key) && typeof _this.fs._impl[key] === "function";
        })
            .reduce(function (accumulator, key) {
            accumulator[key] = util_1.callbackify(_this.fs._impl[key]);
            return accumulator;
        }, {});
    };
    return Store;
}());
exports.Store = Store;
//# sourceMappingURL=store.js.map